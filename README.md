# n-beneficiaries-checker

Прототип сервиса-валидатора заявок на регистрацию бенефициаров номинальных счетов.

Сервис **проверяет пэйлоад заявки на регистрацию бенефициара** и возвращает:

- `200 OK` данные валидны
- `422 VALIDATION_ERROR` ошибки данных/формата/справочников/кросс-полей
- `403 COMPLIANCE_BLOCK` блокирующие регуляторные триггеры (при этом в теле ответа возвращается **полный массив ошибок** для внутренней трассировки)

> Важно: сервис это чистая функция - только проверяет заявки выполняя детерминированную валидацию по правилам. Никаких сайд-эффектов не делает

## Декларативный движок правил

Ключевая ценность сервиса в использовании `json-rules-engine` как **декларативного механизма описания проверок**.

### Что это означает

- Все проверки описываются в JSON-файлах (rulesets), а не зашиваются в коде.
- Правила формируют логическое дерево условий (AND/OR/NOT), включая:
  - простые форматные проверки,
  - кросс-поля (проверки полей зависят от других полей и их значений),
  - условную обязательность,
  - вариативные комплаенс-триггеры.
- Один и тот же пэйлоад может пройти по разным веткам дерева в зависимости от комбинации фактов.

### Что это дает

1. Изменение требований не требует переписывания кода, достаточно обновить ruleset (гибко)
2. Легко добавлять новые beneficiary_type или regulatory-пакеты (масштабируемо)
3. Можно параллельно поддерживать несколько версий логики (версионирование)
4. Каждое сработавшее правило имеет `ruleId`, что упрощает трассировку (прозрачно для поддержки)
5. Итог всегда формируется из набора событий движка по одинаковому алгоритму агрегации (предсказуемо)

Другими словами, сервис строит дерево проверок, в котором на основании входных фактов вычисляется итоговое состояние заявки (OK или VALIDATION_ERROR или COMPLIANCE_BLOCK).

## Как устроен движок

1. **HTTP API** принимает запрос `POST /beneficiaries/validate` и читает `X-Merchant-Id`.
2. Загружается `merchant_config`:
   - `default` базовые требования для всех мерчантов
   - `merchants[<id>]` набор правил перекрывающий базовые требования (и опционально версия правил)
3. Выбирается **версия правил** (`rulesetVersion`):
   - `merchant.ruleset_version` если задана
   - иначе `default.ruleset_version`
4. Загружаются словари (`/dictionaries`).
5. Загружается набор правил из `rulesets/<rulesetVersion>/...`:
   - `regulatory/*` (FATCA/USA и т.п.)
   - `<beneficiary_type>/*` (format + cross)
   - есть фолбэк: если файл отсутствует в выбранной версии, он берется из `default.ruleset_version`
6. Строятся факты из пэйлоада (flatten) + derived facts.
7. Прогоняется `json-rules-engine`, собираются события.
8. Ошибки агрегируются (детерминированно): подавления `REQUIRED > FORMAT`, `FORMAT > CROSS`, дедупликация, сортировка.
9. Возвращается унифицированный ответ.

### Схема (упрощенно)

```text
validate(пэйлоад, merchantId)
  ├─ load merchant_config → choose rulesetVersion
  ├─ build facts (flatten + derived)
  └─ run rules engine
      ├─ REQUIRED / FORMAT (data quality)
      │    ├─ required_fields_by_type[fl_resident]
      │    └─ dictionaries (doc types, country codes, ...)
      ├─ CROSS (business consistency)
      │    └─ e.g. issue_date ≥ birth_date
      └─ REGULATORY (blocking)
           ├─ USA indicia (birth_place / address country_code=840 / etc.)
           └─ FATCA flags (missing → 422, explicit → 403)

engine emits events → aggregator
  ├─ suppress: REQUIRED > FORMAT, FORMAT > CROSS
  ├─ dedupe + stable sort
  └─ decide HTTP: 403 if any BLOCK else 422 if errors else 200
```

## Остальные фичи прототипа

### 1) Версионирование правил (rulesets)

- Правила лежат в `rulesets/<version>/...`.
- Версия выбирается из `merchant_config`.
- Поддержан **фолбэк** на дефолтную версию: удобно для “patch”-версий, где меняется 1–2 файла.

### 2) Merchant config: required_fields + overrides

- Есть `required_fields_by_type` (per beneficiary_type).
- Есть `overrides` per merchant с точным/префиксным матчинговым механизмом и alias mapping для вложенных полей.

### 3) Единый формат ошибок и агрегация

- Для `400/422/403` тело ответа имеет единый формат (`status`, `rulesetVersion`, `errorDesc`, `errors[]`).
- При `403` возвращается **полный список** ошибок (включая validation), т.к. чекер сейчас внутренняя кухня.
- Детерминированный порядок ошибок и подавления (чтобы тесты не флапали).

### 4) Регуляторные триггеры

- `FATCA/USA`: missing flags → `422`, явные триггеры → `403`.
- USA по адресу определяется **по `country_code=840`**, без парсинга строк.

### 5) Адреса

- Для РФ (`country_code=643`) адрес ожидается структурированным.
- Для иностранного адреса строка.
- ФИАС-валидации нет (по банковской практике).

## Конфигурация версий правил

Файл: `config/merchant_config.json`

- `default.ruleset_version` версия “как у всех”
- `merchants[merchantId].ruleset_version` опциональное переопределение

## Запуск

```bash
npm i
npm start
```

## Тестирование

Postman-коллекция: `postman/fl_resident.postman_collection.json`

Группа **Versioning demo** проверяет:

- выбор дефолтной версии
- выбор версии по merchant_config
- фолбэк на дефолтную версию при неполном ruleset
