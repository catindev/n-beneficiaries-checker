# Описание от нейронки цепочки обсуждения в которой пришли к этому прототипу

1. Как вообще организовать pipeline валидации
   Первый вопрос который ты задал — синхронный pipeline или асинхронный через Kafka. Боль была в том что в БТ есть сценарии с ЕГРЮЛ/ЕГРИП которые принципиально асинхронны, но городить Kafka ради валидации казалось избыточным.
   Прототип решает это уходом от вопроса вообще: n-beneficiaries-checker — чистый синхронный валидатор без управления процессом. Асинхронность — проблема оркестратора.

2. Один pipeline для всех или 6 отдельных кейсов
   Ты заметил что внутри каждого типа бенефициара есть логика "если поле заполнено — проверяй одно, если нет — другое". Первая интуиция — сделать 6 отдельных схем. Вторая — что это не 6 схем, а дерево решений которое собирает нужный набор проверок динамически.
   Прототип решает это через Context Builder + Validation Plan: по beneficiary_type в payload собирается конкретный набор файлов правил. Добавить новый тип = создать папку rules/ul_resident/ с двумя JSON-файлами. Без изменений в коде.

3. JSON Schema vs что-то другое для условной логики
   Ты спросил может ли JSON Schema описать логику типа "если поле A заполнено — поле B не нужно". Сам же и заподозрил проблему: if/then/else в JSON Schema работает, но при глубокой вложенности превращается в нечитаемый JSON который никто не может поддерживать.
   Прототип решает это через json-rules-engine: каждое правило — отдельный именованный объект с понятными conditions и event. Вложенность не нужна — правила плоские, каждое делает одно. Условная логика "если A — то проверяй B" выражается через условие присутствия поля внутри самого правила.

4. Справочники захардкожены в правилах
   Ты увидел что заблокированные коды гражданства (["US"]) лежат прямо в теле правила. Боль: придут данные от ЦФТ — нужно лезть в каждое правило и менять. Спросил есть ли готовое решение.
   Прототип решает это через механизм $ref: в правиле пишется { "$ref": "dictionaries.citizenship.blocked" }, при загрузке resolveRefs() подставляет актуальный массив из citizenship.json. Поменять список заблокированных стран = отредактировать один JSON-файл словаря.

5. Кросс-поля — сравнение одного факта с другим
   Когда дошли до правила "дата выдачи паспорта не может быть раньше даты рождения" — возникла проблема: json-rules-engine сравнивает факт с константой, а не факт с фактом. В правиле нельзя написать "сравни passport.issue_date с birth_date".
   Прототип решает это через механизм $fact в fact-resolver.js: перед запуском движка resolveFactRefs() обходит правила и подставляет вместо { "$fact": "birth_date" } реальное значение из текущего payload. Движок получает уже подставленное значение и сравнивает корректно.

6. Движок падает на отсутствующих полях
   Когда запустили первые тесты — сервис падал с Undefined fact: contacts.email. json-rules-engine бросает исключение если факт вообще не существует в объекте, даже когда правило просто проверяет его наличие через fieldPresent.
   Первые два варианта решения (список путей в коде, регистрация каждого факта отдельной функцией) ты отверг как костыли — хардкод остаётся хардкодом.
   Прототип решает это через collectFactPaths(): функция рекурсивно обходит уже загруженные правила, собирает все пути фактов в Set, и проставляет null для тех которых нет в payload. Список фактов выводится автоматически из правил — добавил новое правило с новым полем, оно подхватится без изменений в коде.

7. Конфигурация обязательных полей per-мерчант
   В БТ есть требование что разные мерчанты могут иметь разные наборы обязательных полей. Как это реализовать без дублирования правил?
   Прототип решает это соглашением по именованию: правила на обязательность поля называются {field}\_present. При загрузке движка такие правила фильтруются через merchantConfig.required_fields — если поле не входит в конфиг мерчанта, правило просто не добавляется в движок. Один набор правил покрывает всех мерчантов.

8. Комплаенс-эскалации не должны видеть мерчанты
   БТ требует: если fatca_resident = НЕТ но есть косвенные признаки США — не блокировать, но тайно направить на ручную проверку комплаенсу. Как это реализовать технически?
   Прототип решает это через отдельный тип события COMPLIANCE_ESCALATION: движок его фиксирует, index.js пишет в audit log, но в HTTP-ответ мерчанту не включает. В ходе тестирования обнаружили gap (Д-030) — эскалация по FATCA недостижима потому что место рождения "США" всегда триггерит блокировку раньше. Вопрос открыт к бизнесу.
