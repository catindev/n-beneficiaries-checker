# Реестр принятых решений (decisions_register)

**Прототип:** сервис валидации бенефициаров номинальных счетов  
**Дата обновления:** 2026-02-28  
**Статус:** актуально для прототипа (до оркестратора)

> Формат: решения пронумерованы как `DR-XXX`. Для каждого решения указаны: смысл, мотивация, последствия и заметки по реализации/тестам.

---

## DR-001. FATCA/USA flags: отсутствие = 422 (ошибка данных)

### Решение
Если в запросе отсутствует `fatca_resident` или `usa_resident`, это трактуется как **ошибка данных** и возвращается **HTTP 422 (VALIDATION_ERROR)**.

### Мотивация
Снизить ложные комплаенс-триггеры и не превращать «неполный payload» в регуляторную блокировку.

### Последствия
- Postman: кейсы «поле отсутствует» ожидают **422**, а не 403.
- `403 COMPLIANCE_BLOCK` применяется только при **явном блокирующем значении/индикаторе**, а не при отсутствии поля.

---

## DR-002. При наличии блокирующего regulatory-триггера возвращаем 403, но показываем все ошибки

### Решение
Если сработал хотя бы один блокирующий `REGULATORY`-контроль:
- HTTP статус = **403**
- в теле ответа чекера возвращается **полный массив ошибок**: и `REGULATORY`, и `VALIDATION` (format/required/dict/cross).

### Мотивация
На стадии прототипа чекер — «внутренняя кухня». Полный массив ошибок полезен для трассировки, тестирования и быстрой диагностики. Решение «что прокидывать мерчанту» будет принято на уровне оркестратора.

### Последствия
- 403 не означает, что остальные ошибки «скрыты».
- Тесты должны проверять и статус, и наличие ошибок по нужным кодам/категориям.

---

## DR-003. Единый формат тела ответа для ошибок, включая 400

### Решение
Ответы чекера для ошибок (включая **HTTP 400**, например отсутствие `X-Merchant-Id`) унифицированы и содержат:
- `status`
- `rulesetVersion`
- `errorDesc`
- `errors[]` (структурированные ошибки)

### Мотивация
Упростить трассировку и тестирование: любой неуспех имеет единый формат и диагностируется одинаково.

### Последствия
- Postman может всегда проверять наличие `status`/`errors[]`, даже для 400.
- Middleware/валидация заголовков не должны возвращать «нестандартные» тела.

---

## DR-004. Канонический формат дат во входном API: только YYYY-MM-DD

### Решение
Все date-поля во входном API принимаются **строго** в формате `YYYY-MM-DD`. Любые другие форматы (`ДД.ММ.ГГГГ`, `ДД-ММ-ГГГГ` и т.п.) → **422**.

### Мотивация
Убрать неоднозначность форматов и предотвратить лавину edge-case’ов на кросс-проверках (особенно перед добавлением `fl_nonresident`, где дат больше).

### Последствия
- Ранее «позитивные» тесты с `ДД.ММ.ГГГГ` становятся негативными (422).
- В документации API формат дат фиксируется как ISO-only.

---

## DR-005. Адреса: не становимся интеграционным сервисом; формат зависит от страны

### Решение
Соблюдаем банковскую практику: чекер **не валидирует ФИАС** и не нормализует адрес как интеграционный сервис.

Формат передачи:
- если адрес РФ (`country_code = 643`) — адрес передаётся **структурировано** (набор элементов/частей);
- если адрес иностранный (`country_code != 643`) — адрес передаётся **одной строкой**;
- `country_code` передаётся отдельным полем для выбора режима валидации и комплаенс-триггеров.

### Последствия
- В клиентской документации описывается структура адреса РФ и формат иностранного адреса-строки.
- В чекере проверки адресов ограничены структурой/обязательностью/форматом (без внешних интеграций).

---

## DR-006. Интерпретация требования «США в адресе» через country_code=840

### Решение
Требование БТ «если в адресе фигурирует США — регистрация невозможна» реализуется **не** строковым поиском, а по структурному признаку:
- если `country_code = 840` (USA) хотя бы у одного адресного блока, где применим контроль → **403 COMPLIANCE_BLOCK**.

### Мотивация
Строковый парсинг адресов нестабилен (язык/форматы/опечатки). `country_code` делает проверку детерминированной и масштабируемой.

### Последствия
- Для любых адресов (регистрация/почтовый/иностранный) контроль США выполняется одинаково — по коду страны.

---

## DR-007. Семантика fl_nonresident: миграционный нерезидент, но налоговый резидент РФ

### Решение
`fl_nonresident` в проекте означает: **миграционный/гражданский нерезидент** (иностранный гражданин/ЛБГ), но **налоговый резидент РФ**. Следовательно:
- ИНН РФ для ФЛ обязателен (российский формат, checksum).

### Мотивация
Соответствие БТ: ФЛ должны быть налоговыми резидентами РФ (ИНН российского формата). `fl_nonresident` расширяет документные/миграционные блоки, а не вводит «ФЛ без ИНН».

### Последствия
- INN-логика не ветвится между resident/nonresident; меняются документные и миграционные требования.

---

## DR-008. Миграционная карта / документ пребывания и ЕАЭС: без расчёта 30 суток

### Решение
Чекер **не рассчитывает** срок 30 суток пребывания (нет источника даты въезда).
- Если `citizenship = Беларусь` — `migration_card` не обязательна.
- Для иных стран ЕАЭС отсутствие `migration_card` допустимо **без расчётов срока**; контроль 30 суток — вне чекера.
- Если не передан ни `stay_document`, ни `migration_card` (и нет исключения по гражданству) → **422**.
- Если переданы обе ветки одновременно — это **не ошибка**.

### Последствия
- OR-логика (stay vs migration) реализуется как валидация наличия ветки + минимальные форматные проверки, без календарных вычислений.

---

## DR-009. isForeignIdDoc: вычисляется по группе doc_type_code; флаг — только консистентность; CRS trigger

### Решение
Признак «документ иностранного гражданина/ЛБГ» (`isForeignIdDoc`) определяется по группе `passport.doc_type_code` **31–37, 99**.
- Входной флаг из запроса используется только для проверки консистентности (не может быть “НЕТ”, если `doc_type_code` из группы).
- Триггер включения CRS/foreign tax блока: `isForeignIdDoc = ДА` **и/или** адрес не РФ.

### Последствия
- Убираем неоднозначность «кто такой иностранец» через citizenship/строки; признак детерминирован.
- Опционально позже (на уровне оркестратора) можно исключить входной флаг из внешнего API.

---

## DR-010. Версионирование rulesets: default в merchant_config + per-merchant override + fallback

### Решение
Реализовано версионирование наборов правил:
- правила лежат в `rulesets/<version>/...`
- `default.ruleset_version` хранится в `merchant_config`
- `merchants[merchantId].ruleset_version` может переопределять версию для конкретного мерчанта
- fallback: если файл отсутствует в выбранной версии — берём его из default-версии.

### Мотивация
Безопасно добавлять новые кейсы/уточнять правила без поломки «базовой» логики; включать новые версии точечно.

### Последствия
- Любой расчёт трассируется по `rulesetVersion`.
- Можно выпускать “patch”-версии (например, v1.1) без копирования всего ruleset.

---

## DR-011. Агрегация ошибок: без short-circuit, подавления и детерминированный порядок

### Решение
Чекер возвращает **агрегированный** список ошибок по одному запросу:
- проверки не обрываются на первой ошибке;
- подавления: `REQUIRED` подавляет `FORMAT/DICT` для того же поля; `FORMAT` подавляет зависимые `CROSS`;
- дедупликация по `(field, code)`;
- стабильная сортировка (категория → field → code) для детерминированных тестов.

### Последствия
- Мерчант/тестировщик видит полный “срез” проблем данных.
- Postman/регрессионные тесты не «флапают» из-за случайного порядка ошибок.
